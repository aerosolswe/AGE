uniform sampler2D shadowMap0;
uniform sampler2D shadowMap1;
uniform sampler2D shadowMap2;
uniform sampler2D shadowMap3;

uniform vec3 eyePos;
uniform sampler2D diffuse;
uniform sampler2D normalMap;
uniform sampler2D bumpMap;

uniform float specularIntensity;
uniform float specularPower;
uniform float scale;
uniform float bias;
uniform float shadowMapSize;

vec3 worldPos;
vec2 textureCoords;
mat3 tbnMatrix;

struct BaseLight{
    vec3 color;
    float intensity;
};

struct Attenuation{
    float constant;
    float linear;
    float exponent;
};

struct PointLight{
    BaseLight base;
    Attenuation atten;
    vec3 position;
    float range;
};

struct SpotLight{
    PointLight pointLight;
    vec3 direction;
    float cutoff;
};

struct DirectionalLight{
    BaseLight base;
    vec3 direction;
};

void init(vec3 wp, vec2 tc, mat3 m){
    worldPos = wp;
    textureCoords = tc;
    tbnMatrix = m;
}

vec4 calcLight(BaseLight base, vec3 direction, vec3 normal){
    float diffuseFactor = dot(normal, -direction);

    vec4 diffuseColor = vec4(0,0,0,0);
    vec4 specularColor = vec4(0,0,0,0);

    if(diffuseFactor > 0)
    {
        diffuseColor = vec4(base.color, 1.0) * base.intensity * diffuseFactor;

        vec3 directionToEye = normalize(eyePos - worldPos);
        vec3 reflectDirection = normalize(reflect(direction, normal));

        float specularFactor = dot(directionToEye, reflectDirection);
        specularFactor = pow(specularFactor, specularPower);

        if(specularFactor > 0)
        {
            specularColor = vec4(base.color, 1.0) * specularIntensity * specularFactor;
        }
    }

    return diffuseColor + specularColor;
}

vec4 calcPointLight(PointLight pointLight, vec3 normal){
    vec3 lightDirection = worldPos - pointLight.position;
    float distanceToPoint = length(lightDirection);

    if(distanceToPoint > pointLight.range)
        return vec4(0,0,0,0);

    lightDirection = normalize(lightDirection);

    vec4 color = calcLight(pointLight.base, lightDirection, normal);

    float attenuation = pointLight.atten.constant +
                         pointLight.atten.linear * distanceToPoint +
                         pointLight.atten.exponent * distanceToPoint * distanceToPoint +
                         0.0001;

    return color / attenuation;
}

vec4 calcSpotLight(SpotLight spotLight, vec3 normal){
    vec3 lightDirection = normalize(worldPos - spotLight.pointLight.position);
    float spotFactor = dot(lightDirection, spotLight.direction);

    vec4 color = vec4(0,0,0,0);

    if(spotFactor > spotLight.cutoff){
        color = calcPointLight(spotLight.pointLight, normal) *
                (1.0 - (1.0 - spotFactor)/(1.0 - spotLight.cutoff));
    }

    return color;
}

vec4 calcDirectionalLight(DirectionalLight directionalLight, vec3 normal){
    return calcLight(directionalLight.base, -directionalLight.direction, normal);
}

vec2 calcTextureCoords(){
    vec2 texCoords = textureCoords.xy + ((normalize(eyePos - worldPos) * tbnMatrix).xy *
                                (texture(bumpMap, textureCoords.xy).r * scale + bias));

    return texCoords;
}

vec4 calcTextureColor(){
    vec4 textureColor = texture(diffuse, calcTextureCoords());

    if(textureColor.a < 0.5)
       discard;

    return textureColor;
}

vec3 calcNormal(){
    vec3 normal = normalize(tbnMatrix * (2.0 * texture(normalMap, calcTextureCoords()).xyz - 1.0));

    return normal;
}


float calcShadowFactor(vec4 shadowCoord0, vec4 shadowCoord1, vec4 shadowCoord2, vec4 shadowCoord3){
    vec4 shadowCoord;
    float distanceToCamera = length(worldPos - eyePos);

    float offsetFactor;

    float distance0 = 5; // 2.5
    float distance1 = 15; // 7.5
    float distance2 = 60; // 30 // 500

    if(distanceToCamera < distance0)
        shadowCoord = shadowCoord0;
    else if(distanceToCamera < distance1)
        shadowCoord = shadowCoord1;
    else if(distanceToCamera < distance2)
        shadowCoord = shadowCoord2;
    else
        shadowCoord = shadowCoord3;

    shadowCoord /= shadowCoord.w;

    float shadowFactor = 0.0;

    float PCFOffset = 1.0/shadowMapSize;//0.001;
    const float PCFFactor = 5.0;
    const float SHADOW_BIAS = 0.00000; // 0.005

    for(float i = -PCFOffset; i < PCFOffset; i += 2*PCFOffset/(PCFFactor)){
      for(float j = -PCFOffset; j < PCFOffset; j += 2*PCFOffset/(PCFFactor)){
          float shadowMapValue;

          if(distanceToCamera < distance0)
              shadowMapValue = texture(shadowMap0, shadowCoord.xy + vec2(i,j)).r;
          else if(distanceToCamera < distance1)
              shadowMapValue = texture(shadowMap1, shadowCoord.xy + vec2(i,j)).r;
          else if(distanceToCamera < distance2)
              shadowMapValue = texture(shadowMap2, shadowCoord.xy + vec2(i,j)).r;
          else
              shadowMapValue = texture(shadowMap3, shadowCoord.xy + vec2(i,j)).r;

          if(shadowMapValue < (shadowCoord.z - SHADOW_BIAS))
              shadowFactor += 0.0;
            else
              shadowFactor += 1.0;
        }
    }

    shadowFactor /= (PCFFactor * PCFFactor);

    return shadowFactor;
}